# Task01_数组

组队学习详情：https://github.com/datawhalechina/team-learning/blob/master/数据结构与算法（上）/学习任务.md

目录：

<a href="#理论部分">理论部分</a>

<a href="#练习部分">练习部分</a>

## 理论部分

### 1 数组定义

- 数组是一种线性数据结构，用连续的存储空间存储相同类型数据
- 线性表：数组、链表、队列、栈 非线性表：树、图
- 连续的内存空间、相同的数据，所以数组可以随机访问；但对数组进行删除、插入时，为了保证数组的连续性，就要做大量的数据搬移工作

### 2 数组实现随机访问

* 数组如何实现下标随机访问？
  引入数组在内存中的分配图，得出寻址公式。

* 纠正数组和链表的错误认识。

  数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。
  正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）。

### 3 低效的插入和删除

* 插入：最好 O（1）	最坏 O（n）	平均 O（n）
  插入：数组若无序，插入新的元素时，可以将第 K 个位置元素移动到数组末尾，把新的元素，插入到第 k 个位置，此处复杂度为 O(1)。
* 删除：最好 O（1）	最坏 O（n）	平均 O（n）
  多次删除集中在一起，提高删除效率。
  记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。例如Java的JVM的垃圾回收算法。

### 4 警惕数组的访问越界问题

用 C 语言循环越界访问的例子说明访问越界的bug。此例在《C陷阱与缺陷》出现过，很惭愧，看过但是现在也只有一丢丢印象。翻了下书，替作者加上一句话：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”

原因：

> 这里要了解栈这个东西。栈是向下增长的，首先压栈的 i，arr[2]，arr[1]，arr[0]。相当于访问 arr[3] 的时候，是在访问i变量，而此时 i 变量的地址是数组当前进程的，所以进行修改的时候，操作系统并不会终止进程。

### 5 容器能否完全替代数组

相比于数字，Java 中的 ArrayList 封装了数组的很多操作，并支持动态扩容。一旦超过预先设定的容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。
数组适合的场景：

* Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组。
* 若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组。
* 表示多维数组时，数组往往更加直观。
* 业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。如果是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

### 6 为什么数组要从 0 开始编号，而不是从 1 开始呢

- 从偏移角度理解 a[0]

- 为什么循环要写成`for(int i = 0;i<3;i++)` 而不是`for(int i = 0;i<=2;i++)`。

  因为第一个直接就可以算出 3 - 0 = 3 有三个数据，而后者 2-0+1 个数据，多出 1 个加法运算，很恼火。

- 也有一定的历史原因

## 练习部分

以下代码都为 `python` 版本

### 1 利用动态数组解决数据存放问题

编写一段代码，要求输入一个整数`N`，用动态数组`A`来存放`2~N`之间所有5或7的倍数，输出该数组。

示例：

```python
输入：
N = 100 

输出：
5 7 10 14 15 20 21 25 28 30 35 40 42 45 49 50 55 56 60 63 65 70 75 77 80 84 85 90 91 95 98 100
```

代码：

```python
a = int(input())
b = [None if a < 5 else i for i in range(5, a+1, 5)]
c = [None if a < 7 else i for i in range(7, a+1, 7)]
d = list(set(b+c))
for i in d:
    print(i)
```

### 2 托普利茨矩阵问题

如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。

给定一个`M x N`的矩阵，当且仅当它是托普利茨矩阵时返回`True`。

示例：

```python
输入:
matrix = [
  [1,2,3,4],
  [5,1,2,3],
  [9,5,1,2]
]

输出: True
```

解释:

在上述矩阵中, 其对角线为: `"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]"`。 各条对角线上的所有元素均相同, 因此答案是`True`。

代码：

```python
class Solution(object):
    def isToeplitzMatrix(matrix):
        for i in range(len(matrix) - 1):
            if not matrix[i][:-1] == matrix[i+1][1:]:
                return False
            return True
```

### 3 三数之和

https://leetcode-cn.com/problems/3sum/

给定一个包含 n 个整数的数组`nums`，判断`nums`中是否存在三个元素`a，b，c`，使得`a + b + c = 0`？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例：

```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

代码：

```python
"""
算法流程：
    特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回 []。
    对数组进行排序。
    遍历排序后数组：
        若 nums[i]>0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。
        对于重复元素：跳过，避免出现重复解
        令左指针 L=i+1，右指针 R=n−1，当 L<R时，执行循环：
            当nums[i]+nums[L]+nums[R]==0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,RL,RL,R 移到下一位置，寻找新的解
            若和大于0，说明 nums[R] 太大，R 左移
            若和小于0，说明 nums[L] 太小，L 右移
"""
class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        n = len(nums)
        res = []
        if(not nums or n < 3):
            return []
        nums.sort()
        for i in range(n):
            if (nums[i] > 0):
                return res
            if (i > 0 and nums[i] == nums[i-1]):
                continue
            left = i+1
            right = n-1
            while(left < right):
                if(nums[i] + nums[left] + nums[right] == 0):
                    res.append([nums[i], nums[left], nums[right]])
                    while(left < right and nums[left] == nums[left + 1]):
                        left += 1
                    while(left < right and nums[right] == nums[right - 1]):
                        right -= 1
                    left += 1
                    right -= 1
                elif(nums[i] + nums[left] + nums[right] > 0):
                    right -= 1
                else:
                    left += 1
        return res
```

